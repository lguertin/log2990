/* tslint:disable:only-arrow-functions */

import { expect } from "chai";
import { BlackCellFiller } from "../crossword-content-filler/blackCellFiller";
import { CrossWordGrid } from "../types/crosswordGrid";
import { GRID_DIMENTION, Direction, BLACK_CELL } from "../../../../../../common/crossword/constant";
import { MINIMUM_WORD_LENGTH } from "../constant";

interface BlackCellPosition {
    readonly i: number;
    readonly j: number;
}

export const blackCellLocations1: Array<BlackCellPosition> = [
    {i: 1, j: 2},
    {i: 1, j: 1},
    {i: 1, j: 2},
    {i: 1, j: 3},
    {i: 2, j: 2},
];

export const blackCellLocations2: Array<BlackCellPosition> = [
    {i: 0, j: 2},
    {i: 1, j: 1},
    {i: 1, j: 3},
    {i: 2, j: 2}
];

export const blackCellLocations3: Array<BlackCellPosition> = [
    {i: 0, j: 0},
    {i: 0, j: 4},
    {i: 1, j: 1},
    {i: 1, j: 4},
    {i: 2, j: 2},
    {i: 2, j: 4},
    {i: 3, j: 3},
    {i: 4, j: 2},
    {i: 4, j: 5},
    {i: 5, j: 0},
    {i: 5, j: 3},
    {i: 5, j: 4},
    {i: 5, j: 5}
];

export const SMALL_GRID: number = 5;
export const MEDIUM_GRID: number = 6;

const grid10x10: CrossWordGrid = new CrossWordGrid(GRID_DIMENTION);
BlackCellFiller.execute(grid10x10);

/*  WWBWW
    WBBBW
    WWBWW
    WWWWW
    WWWWW
*/
const gridTest1: CrossWordGrid = new CrossWordGrid(SMALL_GRID);
setBlackCells(gridTest1, blackCellLocations1);

/*  WWBWWW
    WBWBWW
    WWBWWW
    WWWWWW
    WWWWWW
    WWWWWW
*/
const gridTest2: CrossWordGrid = new CrossWordGrid(MEDIUM_GRID);
setBlackCells(gridTest2, blackCellLocations2);

/*  BWWWBW
    WBWWBW
    WWBWBW
    WWWBWW
    WWBWWB
    BWWBBB
*/
const gridTest3: CrossWordGrid = new CrossWordGrid(MEDIUM_GRID);
setBlackCells(gridTest3, blackCellLocations3);

describe("BlackCellFiller", () => {
    describe("Validation of test functions for BlackCellFiller", () => {
        it("should check if there is no isolated cell if a black cell is surrounded by black cells", () => {
            expect(isValidCellsPosition(gridTest1)).to.equal(true);
        });
        it("should have an isolated cell if a white cell is surrounded by black cells", () => {
            expect(isValidCellsPosition(gridTest2)).to.equal(false);
        });
        it("should not get any isolated cells with a proper grid", () => {
            expect(isValidCellsPosition(gridTest3)).to.equal(true);
        });
        it("should not have minimum 1 word per line or column if max length per word is 1", () => {
            expect(isValidByWordRatio(gridTest1)).to.equal(false);
        });
        it("should have minimum 1 word per line or column if there is 2 consecutive white cells", () => {
            expect(isValidByWordRatio(gridTest2)).to.equal(true);
        });
        it("should have minimum 1 word per line or column if there is 2 consecutive white cells", () => {
            expect(isValidByWordRatio(gridTest3)).to.equal(true);
        });
    });

    describe("Filling black cells in " + GRID_DIMENTION + "x" + GRID_DIMENTION + " grid", () => {
        it("should not have any isolated cells on grid generated by BlackCellFiller", () => {
            expect(isValidCellsPosition(grid10x10)).to.equal(true);
        });
        it("should have minimum 1 word per line or column", () => {
            expect(isValidByWordRatio(grid10x10)).to.equal(true);
        });
    });
});

/*Function previously tested with previous algorithm*/
function isIsolatedWhiteCell(grid: CrossWordGrid, i: number, j: number): boolean {
    return (grid.isBlackCellAtPosition(i, j - 1) &&
            grid.isBlackCellAtPosition(i, j + 1) &&
            grid.isBlackCellAtPosition(i + 1, j) &&
            grid.isBlackCellAtPosition(i - 1, j));
}

/*Function previously tested with previous algorithm*/
function isValidCellsPosition(grid: CrossWordGrid): boolean {
    let i: number = 0;
    let j: number = 0;
    while (i < grid.getDimension()) {
        j = 0;
        while (j < grid.getDimension()) {
            if (!grid.isBlackCellAtPosition(i, j) && isIsolatedWhiteCell(grid, i, j)) {
                return false;
            }
            j++;
        }
        i++;
    }

    return true;
}

/*Function previously tested with previous algorithm*/
function isValidByWordRatio(grid: CrossWordGrid ): boolean {
    for (let x: number = 0 ; x < grid.getDimension(); x++) {
        let j: number = 0;
        while (grid.getCellsDistanceToBlack(x, j, Direction.HORIZONTAL) < MINIMUM_WORD_LENGTH) {
            j++;
            if (j >= grid.getDimension()) {
                return false;
            }
        }
        let i: number = 0;
        while (grid.getCellsDistanceToBlack(i, x, Direction.VERTICAL) < MINIMUM_WORD_LENGTH) {
            i++;
            if (i >= grid.getDimension()) {
                return false;
            }
        }
    }

    return true;
}

function setBlackCells(grid: CrossWordGrid, blackCellLocations: Array<BlackCellPosition>): void {
    for (const blackCellLocation of blackCellLocations) {
        grid.setCellValue(blackCellLocation.i, blackCellLocation.j, BLACK_CELL);
    }
}
